<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">UIPresets</string>
        <string name="Source">--!strict

---@module src/Types
local Types = require(script.Types);

local UIPresets = {}::Types.UIPresets;

local ItemFieldsContainer: any = script.ItemFields;

local ItemField: Types.Schema_Base_ItemField = require(ItemFieldsContainer:FindFirstChild("ItemField"));
local TextField: Types.Schema_TextField = require(ItemFieldsContainer:FindFirstChild("TextField"));
local EnumField: Types.Schema_EnumField = require(ItemFieldsContainer:FindFirstChild("EnumField"));

local Preset: Types.PresetSchemas = {
    ItemField = ItemField,
    TextField = TextField,
    EnumField = EnumField
};

UIPresets.Preset = Preset;

local Field: Types.Enum_ItemField = {
    TextField = 0,
    EnumField = 1
};

UIPresets.Field = Field;

function UIPresets.newField&lt;T>(itemField: number) : T
    if itemField == Field.TextField then
        
    end
end

local enumField: Types.EnumField = UIPresets.newField(Field.EnumField);

return UIPresets;</string>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">ItemFields</string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">EnumField</string>
            <string name="Source">--!strict
---@module src/Types
local Types = require(script.Parent.Parent.Types);
type EnumField = Types.EnumField;

local ItemField: Types.Schema_Base_ItemField = require(script.Parent.ItemField);

local EnumField = {};
EnumField.__index = EnumField;
setmetatable(EnumField,ItemField);

function EnumField.new() : EnumField
    local self = ItemField.newBase()::Types.Object_EnumField;
    
    return setmetatable(self,EnumField)::EnumField;
end

return EnumField;</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">ItemField</string>
            <string name="Source">---@module src/Types
local Types = require(script.Parent.Parent.Types);
type ItemField = Types.Base_ItemField;

local ItemField = {} :: Types.Schema_Base_ItemField;
ItemField.__index = ItemField;

function ItemField.newBase() : ItemField
    local self = {}::Types.Object_Base_ItemField;
    
    return setmetatable(self,ItemField)::ItemField;
end

return ItemField;</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">TextField</string>
            <string name="Source">--!strict
---@module src/Types
local Types = require(script.Parent.Parent.Types);
type TextField = Types.TextField;

local ItemField: Types.Schema_Base_ItemField = require(script.Parent.ItemField);

local TextField = {};
TextField.__index = TextField;
setmetatable(TextField,ItemField);

function TextField.new() : TextField
    local self = ItemField.newBase()::Types.Object_TextField;

    return setmetatable(self,TextField)::TextField;
end

return TextField;</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">Types</string>
          <string name="Source">-- #region Enum_ItemFields

export type Enum_ItemField = {
    TextField: number,
    EnumField: number
};

-- #endregion

-- #region ItemFields

    -- #region Base_ItemField

    export type Object_Base_ItemField = {
        BackFrame: Frame,
        ItemLabel: TextLabel
    };

    export type Schema_Base_ItemField = {
        __index: any,

        newBase: () -> Base_ItemField
    };

    export type Base_ItemField = Object_Base_ItemField &amp; Schema_Base_ItemField;

    -- #endregion

    -- #region TextField
  
        export type Object_TextField = Object_Base_ItemField &amp; {};

        export type Schema_TextField = Schema_Base_ItemField &amp; {
            new: () -> TextField
        };

        export type TextField = Object_TextField &amp; Schema_TextField;

    -- #endregion

    -- #region EnumField

        export type Object_EnumField = Object_Base_ItemField &amp; {};

        export type Schema_EnumField = Schema_Base_ItemField &amp; {
            new: () -> EnumField
        };

        export type EnumField = Object_TextField &amp; Schema_EnumField;

    -- #endregion

-- #endregion

export type PresetSchemas = {
    ItemField: Schema_Base_ItemField,
    TextField: Schema_TextField,
    EnumField: Schema_EnumField
};

export type UIPresets = {
    Preset: PresetSchemas,
    Field: Enum_ItemField,

    newField:&lt;T> (itemField: number) -> T
};

return true;</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="7">
        <Properties>
          <string name="Name">Packages</string>
        </Properties>
        <Item class="Folder" referent="8">
          <Properties>
            <string name="Name">_Index</string>
          </Properties>
          <Item class="Folder" referent="9">
            <Properties>
              <string name="Name">stravant_goodsignal@0.2.1</string>
            </Properties>
            <Item class="ModuleScript" referent="10">
              <Properties>
                <string name="Name">goodsignal</string>
                <string name="Source">--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">goodsignal</string>
            <string name="Source"><![CDATA[return require(script.Parent._Index["stravant_goodsignal@0.2.1"]["goodsignal"])
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>